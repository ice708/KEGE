# https://education.yandex.ru/ege/task/b5ea1e82-76f7-4781-8ef4-5f462fdc7638

# Два узла, находящиеся в разных подсетях,
# имеют IP-адреса 151.172.115.121 и 151.172.115.156
# В масках обеих подсетей одинаковое количество единиц.
# Укажите наименьшее возможное количество единиц в масках этих подсетей.

# ===============

# ГРОМОЗДКОЕ РЕШЕНИЕ без использования модуля ipaddress

# Определяем функцию ip_to_binary, которая преобразует IP-адрес в бинарный формат
def ip_to_binary(ip):
    # Используем генераторное выражение для преобразования каждого октета IP-адреса в бинарный формат
    # format(int(i), '08b') преобразует целое число в бинарный формат, заполняя нулями до 8 бит
    # join объединяет все бинарные октеты в одну строку
    return ''.join(format(int(i), '08b') for i in ip.split('.'))

# Определяем функцию find_mask, которая находит маску, которая отличает два IP-адреса
def find_mask(ip1, ip2):
    # Преобразуем IP-адреса в бинарный формат
    binary_ip1 = ip_to_binary(ip1)
    binary_ip2 = ip_to_binary(ip2)

    # Ищем маску, которая отличает два IP-адреса
    # Мы пробуем все возможные длины маски от 0 до 32
    for mask_length in range(32):
        # Создаем бинарную маску, состоящую из mask_length единиц и 32 - mask_length нулей
        binary_mask = '1' * mask_length + '0' * (32 - mask_length)
        
        # Проверяем, отличаются ли два IP-адреса при применении текущей маски
        # int(binary_ip1, 2) & int(binary_mask, 2) выполняет побитовое И между IP-адресом и маской
        # Если результаты для двух IP-адресов различны, то текущая маска отличает их
        if (int(binary_ip1, 2) & int(binary_mask, 2)) != (int(binary_ip2, 2) & int(binary_mask, 2)):
            # Преобразуем бинарную маску обратно в IP-адрес
            # join объединяет все октеты маски в одну строку
            return '.'.join(str(int(binary_mask[i:i+8], 2)) for i in range(0, 32, 8))

# Определяем функцию mask_to_binary, которая преобразует маску в бинарный формат
def mask_to_binary(mask):
    # Преобразуем каждый октет маски в бинарный формат
    # format(int(octet), '08b') преобразует целое число в бинарный формат, заполняя нулями до 8 бит
    # join объединяет все бинарные октеты в одну строку
    binary_mask = ''.join(format(int(octet), '08b') for octet in mask.split('.'))
    
    # Возвращаем бинарную маску в формате строки и количество единиц в маске
    return '.'.join([binary_mask[i:i+8] for i in range(0, 32, 8)]), binary_mask.count('1')

# Определяем два IP-адреса
ip1 = '151.172.115.121'
ip2 = '151.172.115.156'

# Ищем маску, которая отличает два IP-адреса
mask = find_mask(ip1, ip2)

# Преобразуем маску в бинарный формат
binary_mask, ones_count = mask_to_binary(mask)

# Выводим результаты
print(f"Маска сети: {mask}")
print(f"Бинарная маска: {binary_mask}")
print(f"Количество единиц: {ones_count}")